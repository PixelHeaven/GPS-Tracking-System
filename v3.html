<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra GPS Tracker Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .header {
            background: linear-gradient(135deg, #2196f3, #21cbf3);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }
        
        .header h1 {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 10px;
            cursor: pointer;
        }
        
        .header .subtitle {
            font-size: 16px;
            opacity: 0.9;
        }
        
        .main-content {
            padding: 30px;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
        }
        
        .btn-group.triple {
            gap: 5px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }
        
        .btn:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .btn:hover:before {
            left: 100%;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #4caf50, #45a049);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(76, 175, 80, 0.3);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
        }
        
        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(244, 67, 54, 0.3);
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #ff9800, #f57c00);
            color: white;
        }
        
        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 152, 0, 0.3);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #607d8b, #455a64);
            color: white;
        }
        
        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(96, 125, 139, 0.3);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .status-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .status-card {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #2196f3;
        }
        
        .status-card h3 {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .status {
            font-size: 18px;
            font-weight: 700;
            padding: 5px 15px;
            border-radius: 20px;
            display: inline-block;
        }
        
        .status.active {
            background: #4caf50;
            color: white;
        }
        
        .status.inactive {
            background: #f44336;
            color: white;
        }
        
        .status.online {
            background: #4caf50;
            color: white;
        }
        
        .status.offline {
            background: #f44336;
            color: white;
        }
        
        .coordinates-display {
            background: #1a1a1a;
            color: #00ff00;
            padding: 15px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 20px;
            border: 2px solid #333;
        }
        
        .accuracy-indicator {
            padding: 10px 15px;
            border-radius: 20px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .accuracy-excellent {
            background: #4caf50;
            color: white;
        }
        
        .accuracy-good {
            background: #8bc34a;
            color: white;
        }
        
        .accuracy-fair {
            background: #ff9800;
            color: white;
        }
        
        .accuracy-poor {
            background: #f44336;
            color: white;
        }
        
        .map-container {
            background: #f5f5f5;
            border: 2px solid #ddd;
            border-radius: 15px;
            height: 400px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .map-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #999;
            font-size: 18px;
            background: linear-gradient(45deg, #f0f0f0, #e0e0e0);
        }
        
        #trackCanvas {
            display: none;
            width: 100%;
            height: 100%;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
            transition: transform 0.3s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15);
        }
        
        .stat-card h3 {
            font-size: 16px;
            color: #666;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-card .value {
            font-size: 24px;
            font-weight: 700;
            color: #2196f3;
            margin-bottom: 10px;
        }
        
        .progress-container {
            background: #f0f0f0;
            border-radius: 10px;
            height: 8px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            border-radius: 10px;
            transition: width 0.5s ease;
        }
        
        /* MODAL - FIXED */
        .modal {
            display: none; /* IMPORTANT: Hidden by default */
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 0;
            border-radius: 20px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        .modal-header {
            background: linear-gradient(135deg, #2196f3, #21cbf3);
            color: white;
            padding: 20px 30px;
            border-radius: 20px 20px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 24px;
        }
        
        .close {
            color: white;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            background: none;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.3s;
        }
        
        .close:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .modal-body {
            padding: 30px;
        }
        
        .settings-section {
            margin-bottom: 30px;
        }
        
        .collapsible {
            background: #f8f9fa;
            border: none;
            padding: 15px 20px;
            width: 100%;
            text-align: left;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s;
        }
        
        .collapsible:hover {
            background: #e9ecef;
        }
        
        .chevron {
            transition: transform 0.3s;
        }
        
        .chevron.active {
            transform: rotate(180deg);
        }
        
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: white;
            border-radius: 10px;
            margin-bottom: 15px;
        }
        
        .collapsible-content.active {
            max-height: 500px;
            border: 1px solid #e0e0e0;
        }
        
        .collapsible-inner {
            padding: 20px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }
        
        .form-control {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        .form-control:focus {
            outline: none;
            border-color: #2196f3;
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .modal-footer {
            padding: 20px 30px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 15px;
            justify-content: flex-end;
        }
        
        .connection-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .info-item {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .info-item .label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }
        
                .info-item .value {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }
        
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 15px;
            }
            
            .header {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 24px;
            }
            
            .main-content {
                padding: 20px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .btn-group {
                justify-content: center;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .status-bar {
                grid-template-columns: 1fr;
            }
            
            .modal-content {
                margin: 10px;
                width: calc(100% - 20px);
            }
            
            .modal-header {
                padding: 15px 20px;
            }
            
            .modal-body {
                padding: 20px;
            }
            
            .modal-footer {
                padding: 15px 20px;
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🛰️ Ultra GPS Tracker Pro</h1>
            <div class="subtitle">Professional GPS Tracking with Advanced Analytics</div>
        </div>
        
        <div class="main-content">
            <!-- Control Buttons -->
            <div class="controls">
                <div class="btn-group">
                    <button id="startBtn" class="btn btn-primary" onclick="startTracking()">🚀 Start Tracking</button>
                    <button id="stopBtn" class="btn btn-danger" onclick="stopTracking()" disabled>⏹️ Stop</button>
                </div>
                
                <div class="btn-group">
                    <button id="pauseBtn" class="btn btn-warning" onclick="pauseTracking()" disabled>⏸️ Pause</button>
                    <button id="resumeBtn" class="btn btn-primary" onclick="resumeTracking()" style="display: none;">▶️ Resume</button>
                </div>
                
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="showSettings()">⚙️ Settings</button>
                    <button class="btn btn-danger" onclick="clearData()">🗑️ Clear</button>
                </div>
                
                <div class="btn-group triple">
                    <button id="exportGpxBtn" class="btn btn-secondary" onclick="exportGPX()" disabled>📄 GPX</button>
                    <button id="exportKmlBtn" class="btn btn-secondary" onclick="exportKML()" disabled>🗺️ KML</button>
                    <button id="exportJsonBtn" class="btn btn-secondary" onclick="exportJSON()" disabled>📊 JSON</button>
                </div>
            </div>
            
            <!-- Status Bar -->
            <div class="status-bar">
                <div class="status-card">
                    <h3>Tracking Status</h3>
                    <div id="trackingStatus" class="status inactive">Inactive</div>
                </div>
                
                <div class="status-card">
                    <h3>Connection</h3>
                    <div id="connectionStatus" class="status offline">Offline</div>
                </div>
                
                <div class="status-card">
                    <h3>Data Usage</h3>
                    <div id="dataUsage" class="status">0 KB</div>
                </div>
            </div>
            
            <!-- GPS Coordinates Display -->
            <div id="coordinatesDisplay" class="coordinates-display">
                LAT: -.--------° LON: -.--------°<br>
                ALT: ---.- m  ACC: ---.- m<br>
                SPD: --.- km/h  HDG: ---°<br>
                UTC: ----/--/-- --:--:--
            </div>
            
            <!-- Accuracy Indicator -->
            <div id="accuracyIndicator" class="accuracy-indicator accuracy-poor">
                Accuracy: Initializing...
            </div>
            
            <!-- Map Container -->
            <div class="map-container">
                <div class="map-placeholder">
                    📍 GPS track will appear here when tracking starts
                </div>
                <canvas id="trackCanvas"></canvas>
            </div>
            
            <!-- Statistics Grid -->
            <div class="stats-grid">
                <div class="stat-card">
                    <h3>📊 Track Points</h3>
                    <div id="pointCount" class="value">0 points</div>
                    <div class="progress-container">
                        <div id="pointProgress" class="progress-bar" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="stat-card">
                    <h3>📏 Total Distance</h3>
                    <div id="totalDistance" class="value">0.000 km</div>
                    <div class="progress-container">
                        <div id="distanceProgress" class="progress-bar" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="stat-card">
                    <h3>⏱️ Duration</h3>
                    <div id="duration" class="value">00:00:00</div>
                </div>
                
                <div class="stat-card">
                    <h3>🚗 Average Speed</h3>
                    <div id="avgSpeed" class="value">0.00 km/h</div>
                </div>
                
                <div class="stat-card">
                    <h3>⚡ Max Speed</h3>
                    <div id="maxSpeed" class="value">0.00 km/h</div>
                    <div class="progress-container">
                        <div id="speedProgress" class="progress-bar" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="stat-card">
                    <h3>⛰️ Elevation Gain</h3>
                    <div id="elevGain" class="value">0 m</div>
                </div>
                
                <div class="stat-card">
                    <h3>🎯 Track Precision</h3>
                    <div id="trackPrecision" class="value">0%</div>
                </div>
                
                <div class="stat-card">
                    <h3>🌊 Track Smoothness</h3>
                    <div id="trackSmoothness" class="value">0%</div>
                </div>
                
                <div class="stat-card">
                    <h3>🔄 Sensor Fusion</h3>
                    <div id="fusionStatus" class="value">Inactive</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>⚙️ Advanced Settings</h2>
                <button class="close" onclick="closeSettings()">&times;</button>
            </div>
            <div class="modal-body">
                <!-- GPS Settings -->
                <div class="settings-section">
                    <button class="collapsible" onclick="toggleCollapsible(this)">
                        🛰️ GPS Configuration
                        <span class="chevron">▼</span>
                    </button>
                    <div class="collapsible-content">
                        <div class="collapsible-inner">
                            <div class="form-group">
                                <label for="gpsInterval">Update Interval (ms)</label>
                                <select id="gpsInterval" class="form-control">
                                    <option value="1000">1 second (High precision)</option>
                                    <option value="2000">2 seconds (Balanced)</option>
                                    <option value="5000" selected>5 seconds (Battery saver)</option>
                                    <option value="10000">10 seconds (Ultra saver)</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <div class="checkbox-group">
                                    <input type="checkbox" id="highAccuracy" checked>
                                    <label for="highAccuracy">Enable High Accuracy GPS</label>
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <label for="positionTimeout">Position Timeout (ms)</label>
                                <input type="number" id="positionTimeout" class="form-control" value="15000" min="5000" max="60000">
                            </div>
                            
                            <div class="form-group">
                                <label for="maximumAge">Maximum Age (ms)</label>
                                <input type="number" id="maximumAge" class="form-control" value="10000" min="0" max="300000">
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Filtering Settings -->
                <div class="settings-section">
                    <button class="collapsible" onclick="toggleCollapsible(this)">
                        🔧 Data Filtering
                        <span class="chevron">▼</span>
                    </button>
                    <div class="collapsible-content">
                        <div class="collapsible-inner">
                            <div class="form-group">
                                <div class="checkbox-group">
                                    <input type="checkbox" id="sensorFusion" checked>
                                    <label for="sensorFusion">Enable Sensor Fusion</label>
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <div class="checkbox-group">
                                    <input type="checkbox" id="trackSmoothing" checked>
                                    <label for="trackSmoothing">Enable Track Smoothing</label>
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <label for="minAccuracy">Minimum Accuracy (meters)</label>
                                <input type="number" id="minAccuracy" class="form-control" value="50" min="1" max="1000">
                            </div>
                            
                            <div class="form-group">
                                <label for="minDistance">Minimum Distance (meters)</label>
                                <input type="number" id="minDistance" class="form-control" value="5" min="0" max="100">
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Data Management -->
                <div class="settings-section">
                    <button class="collapsible" onclick="toggleCollapsible(this)">
                        💾 Data Management
                        <span class="chevron">▼</span>
                    </button>
                    <div class="collapsible-content">
                        <div class="collapsible-inner">
                            <div class="form-group">
                                <label for="dataSavingMode">Data Saving Mode</label>
                                <select id="dataSavingMode" class="form-control">
                                    <option value="minimal" selected>Minimal (Offline only)</option>
                                    <option value="balanced">Balanced (Limited online)</option>
                                    <option value="full">Full Features (Online)</option>
                                </select>
                            </div>
                            
                            <div class="connection-info">
                                <div class="info-item">
                                    <div class="label">Storage Used</div>
                                    <div id="storageUsed" class="value">0 KB</div>
                                </div>
                                <div class="info-item">
                                    <div class="label">Points Stored</div>
                                    <div id="pointsStored" class="value">0</div>
                                </div>
                                <div class="info-item">
                                    <div class="label">Session Time</div>
                                    <div id="sessionTime" class="value">00:00</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Advanced Features -->
                <div class="settings-section">
                    <button class="collapsible" onclick="toggleCollapsible(this)">
                        🚀 Advanced Features
                        <span class="chevron">▼</span>
                    </button>
                    <div class="collapsible-content">
                        <div class="collapsible-inner">
                            <div class="form-group">
                                <div class="checkbox-group">
                                    <input type="checkbox" id="enableMapTiles">
                                    <label for="enableMapTiles">Enable Map Tiles (Requires Internet)</label>
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <div class="checkbox-group">
                                    <input type="checkbox" id="enableElevationAPI">
                                    <label for="enableElevationAPI">Enhanced Elevation Data</label>
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <div class="checkbox-group">
                                    <input type="checkbox" id="enableCloudSync">
                                    <label for="enableCloudSync">Cloud Synchronization</label>
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <div class="checkbox-group">
                                    <input type="checkbox" id="enableWeatherData">
                                    <label for="enableWeatherData">Weather Data Integration</label>
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <div class="checkbox-group">
                                    <input type="checkbox" id="deadReckoning">
                                    <label for="deadReckoning">Dead Reckoning (GPS Loss Recovery)</label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeSettings()">Cancel</button>
                <button class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
            </div>
        </div>
    </div>
    
    <script>
        class UltraGPSTracker {
            constructor() {
                this.isTracking = false;
                this.isPaused = false;
                this.watchId = null;
                this.trackData = [];
                this.filteredData = [];
                this.sensorData = [];
                this.totalDistance = 0;
                                this.maxSpeed = 0;
                this.elevationGain = 0;
                this.elevationLoss = 0;
                this.lastElevation = null;
                this.startTime = null;
                this.pausedTime = 0;
                this.pauseStartTime = null;
                this.wakeLock = null;
                
                // Kalman filter variables
                this.kalmanFilter = {
                    lat: { x: 0, p: 1000, q: 0.001, r: 1 },
                    lon: { x: 0, p: 1000, q: 0.001, r: 1 }
                };
                
                // Sensor fusion data
                this.deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
                this.deviceMotion = { x: 0, y: 0, z: 0 };
                this.lastHeading = null;
                this.compassCalibrated = false;
                
                // Data usage tracking
                this.dataUsage = {
                    total: 0,
                    session: 0,
                    mode: 'minimal'
                };
                
                // Canvas for track visualization
                this.canvas = null;
                this.ctx = null;
                this.trackBounds = { minLat: null, maxLat: null, minLon: null, maxLon: null };
                
                this.init();
            }
            
            init() {
                console.log('Initializing Ultra GPS Tracker Pro...');
                this.setupCanvas();
                this.setupSensors();
                this.loadSettings();
                this.updateConnectionDisplay();
                this.startStatusUpdates();
                
                // Request permissions
                this.requestPermissions();
                
                console.log('Ultra GPS Tracker Pro initialized successfully');
            }
            
            async requestPermissions() {
                try {
                    // Request location permission
                    if ('geolocation' in navigator) {
                        console.log('Geolocation API available');
                    } else {
                        throw new Error('Geolocation not supported');
                    }
                    
                    // Request device orientation permission (iOS 13+)
                    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission !== 'granted') {
                            console.warn('Device orientation permission denied');
                        }
                    }
                    
                    // Request device motion permission (iOS 13+)
                    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                        const permission = await DeviceMotionEvent.requestPermission();
                        if (permission !== 'granted') {
                            console.warn('Device motion permission denied');
                        }
                    }
                    
                    // Request wake lock permission
                    if ('wakeLock' in navigator) {
                        console.log('Wake Lock API available');
                    }
                    
                } catch (error) {
                    console.warn('Permission request failed:', error);
                }
            }
            
            setupCanvas() {
                this.canvas = document.getElementById('trackCanvas');
                if (this.canvas) {
                    this.ctx = this.canvas.getContext('2d');
                    this.canvas.width = this.canvas.offsetWidth;
                    this.canvas.height = this.canvas.offsetHeight;
                }
            }
            
            setupSensors() {
                // Device orientation (compass)
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', (event) => {
                        this.deviceOrientation = {
                            alpha: event.alpha || 0,  // Compass heading
                            beta: event.beta || 0,    // Front-to-back tilt
                            gamma: event.gamma || 0   // Left-to-right tilt
                        };
                        this.compassCalibrated = event.absolute || false;
                    });
                }
                
                // Device motion (accelerometer)
                if (window.DeviceMotionEvent) {
                    window.addEventListener('devicemotion', (event) => {
                        const acc = event.accelerationIncludingGravity;
                        if (acc) {
                            this.deviceMotion = {
                                x: acc.x || 0,
                                y: acc.y || 0,
                                z: acc.z || 0
                            };
                        }
                    });
                }
            }
            
            async startTracking() {
                if (this.isTracking) return;
                
                try {
                    // Request wake lock to prevent screen from turning off
                    if ('wakeLock' in navigator) {
                        this.wakeLock = await navigator.wakeLock.request('screen');
                        console.log('Wake lock acquired');
                    }
                    
                    const options = {
                        enableHighAccuracy: document.getElementById('highAccuracy')?.checked ?? true,
                        timeout: parseInt(document.getElementById('positionTimeout')?.value || '15000'),
                        maximumAge: parseInt(document.getElementById('maximumAge')?.value || '10000')
                    };
                    
                    this.watchId = navigator.geolocation.watchPosition(
                        (position) => this.onPositionUpdate(position),
                        (error) => this.onPositionError(error),
                        options
                    );
                    
                    this.isTracking = true;
                    this.isPaused = false;
                    this.startTime = Date.now();
                    this.pausedTime = 0;
                    
                    this.updateUI();
                    this.updateConnectionDisplay();
                    
                    console.log('GPS tracking started');
                    this.showNotification('GPS tracking started', 'success');
                    
                } catch (error) {
                    console.error('Failed to start tracking:', error);
                    this.showError('Failed to start tracking: ' + error.message);
                }
            }
            
            stopTracking() {
                if (!this.isTracking) return;
                
                if (this.watchId !== null) {
                    navigator.geolocation.clearWatch(this.watchId);
                    this.watchId = null;
                }
                
                // Release wake lock
                if (this.wakeLock) {
                    this.wakeLock.release();
                    this.wakeLock = null;
                    console.log('Wake lock released');
                }
                
                this.isTracking = false;
                this.isPaused = false;
                
                this.updateUI();
                this.updateConnectionDisplay();
                
                console.log('GPS tracking stopped');
                this.showNotification('GPS tracking stopped', 'info');
            }
            
            pauseTracking() {
                if (!this.isTracking || this.isPaused) return;
                
                this.isPaused = true;
                this.pauseStartTime = Date.now();
                
                this.updateUI();
                console.log('GPS tracking paused');
                this.showNotification('GPS tracking paused', 'warning');
            }
            
            resumeTracking() {
                if (!this.isTracking || !this.isPaused) return;
                
                this.isPaused = false;
                if (this.pauseStartTime) {
                    this.pausedTime += Date.now() - this.pauseStartTime;
                    this.pauseStartTime = null;
                }
                
                this.updateUI();
                console.log('GPS tracking resumed');
                this.showNotification('GPS tracking resumed', 'success');
            }
            
            onPositionUpdate(position) {
                if (!this.isTracking || this.isPaused) return;
                
                const coords = position.coords;
                const timestamp = position.timestamp;
                
                // Apply Kalman filtering
                const filteredCoords = this.applyKalmanFilter(coords);
                
                // Create GPS point
                const gpsPoint = {
                    latitude: filteredCoords.latitude,
                    longitude: filteredCoords.longitude,
                    altitude: coords.altitude,
                    accuracy: coords.accuracy,
                    altitudeAccuracy: coords.altitudeAccuracy,
                    heading: coords.heading,
                    speed: coords.speed,
                    timestamp: timestamp,
                    sensorData: {
                        orientation: { ...this.deviceOrientation },
                        motion: { ...this.deviceMotion },
                        compassCalibrated: this.compassCalibrated
                    }
                };
                
                // Store raw data
                this.trackData.push(gpsPoint);
                
                // Apply filtering
                if (this.shouldIncludePoint(gpsPoint)) {
                    this.filteredData.push(gpsPoint);
                    this.updateStatistics(gpsPoint);
                    this.updateTrackBounds(gpsPoint);
                    this.drawTrack();
                }
                
                // Update displays
                this.updateCoordinatesDisplay(gpsPoint);
                this.updateAccuracyIndicator(coords.accuracy);
                this.updateStatisticsDisplay();
                
                // Track data usage
                this.trackDataUsage(JSON.stringify(gpsPoint).length);
            }
            
            onPositionError(error) {
                let message = 'GPS Error: ';
                switch (error.code) {
                    case error.PERMISSION_DENIED:
                        message += 'Location access denied by user';
                        break;
                    case error.POSITION_UNAVAILABLE:
                        message += 'Location information unavailable';
                        break;
                    case error.TIMEOUT:
                        message += 'Location request timed out';
                        break;
                    default:
                        message += 'Unknown error occurred';
                        break;
                }
                
                console.error(message);
                this.showError(message);
                
                // Update accuracy indicator
                this.updateAccuracyIndicator(null);
            }
            
            applyKalmanFilter(coords) {
                // Simple Kalman filter implementation
                const lat = this.kalmanFilter.lat;
                const lon = this.kalmanFilter.lon;
                
                if (lat.x === 0) {
                    // Initialize
                    lat.x = coords.latitude;
                    lon.x = coords.longitude;
                } else {
                    // Predict
                    lat.p += lat.q;
                    lon.p += lon.q;
                    
                    // Update
                    const latK = lat.p / (lat.p + lat.r);
                    const lonK = lon.p / (lon.p + lon.r);
                    
                    lat.x += latK * (coords.latitude - lat.x);
                    lon.x += lonK * (coords.longitude - lon.x);
                    
                    lat.p *= (1 - latK);
                    lon.p *= (1 - lonK);
                }
                
                return {
                    latitude: lat.x,
                    longitude: lon.x
                };
            }
            
            shouldIncludePoint(point) {
                const minAccuracy = parseFloat(document.getElementById('minAccuracy')?.value || '50');
                const minDistance = parseFloat(document.getElementById('minDistance')?.value || '5');
                
                // Check accuracy threshold
                if (point.accuracy && point.accuracy > minAccuracy) {
                    return false;
                }
                
                // Check minimum distance
                if (this.filteredData.length > 0) {
                    const lastPoint = this.filteredData[this.filteredData.length - 1];
                    const distance = this.calculateDistance(
                        lastPoint.latitude, lastPoint.longitude,
                        point.latitude, point.longitude
                    );
                    
                    if (distance < minDistance) {
                        return false;
                    }
                }
                
                return true;
            }
            
            updateStatistics(point) {
                // Update distance
                if (this.filteredData.length > 1) {
                    const lastPoint = this.filteredData[this.filteredData.length - 2];
                    const distance = this.calculateDistance(
                        lastPoint.latitude, lastPoint.longitude,
                        point.latitude, point.longitude
                    );
                    this.totalDistance += distance;
                }
                
                // Update max speed
                if (point.speed && point.speed > this.maxSpeed) {
                    this.maxSpeed = point.speed;
                }
                
                // Update elevation gain/loss
                if (point.altitude !== null) {
                    if (this.lastElevation !== null) {
                        const elevDiff = point.altitude - this.lastElevation;
                        if (elevDiff > 0) {
                            this.elevationGain += elevDiff;
                        } else {
                            this.elevationLoss += Math.abs(elevDiff);
                        }
                    }
                    this.lastElevation = point.altitude;
                }
            }
            
            updateTrackBounds(point) {
                if (this.trackBounds.minLat === null) {
                    this.trackBounds.minLat = this.trackBounds.maxLat = point.latitude;
                    this.trackBounds.minLon = this.trackBounds.maxLon = point.longitude;
                } else {
                    this.trackBounds.minLat = Math.min(this.trackBounds.minLat, point.latitude);
                    this.trackBounds.maxLat = Math.max(this.trackBounds.maxLat, point.latitude);
                    this.trackBounds.minLon = Math.min(this.trackBounds.minLon, point.longitude);
                    this.trackBounds.maxLon = Math.max(this.trackBounds.maxLon, point.longitude);
                }
            }
            
            calculateDistance(lat1, lon1, lat2, lon2) {
                const R = 6371000; // Earth's radius in meters
                const dLat = this.toRadians(lat2 - lat1);
                const dLon = this.toRadians(lon2 - lon1);
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                         Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) *
                         Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }
            
            toRadians(degrees) {
                return degrees * (Math.PI / 180);
            }
            
            drawTrack() {
                if (!this.ctx || this.filteredData.length < 2) return;
                
                const canvas = this.canvas;
                const ctx = this.ctx;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Show canvas
                canvas.style.display = 'block';
                canvas.parentElement.querySelector('.map-placeholder').style.display = 'none';
                
                // Calculate scale and offset
                const padding = 20;
                const bounds = this.trackBounds;
                
                                if (bounds.minLat === null) return;
                
                const latRange = bounds.maxLat - bounds.minLat;
                const lonRange = bounds.maxLon - bounds.minLon;
                
                const scaleX = (canvas.width - 2 * padding) / lonRange;
                const scaleY = (canvas.height - 2 * padding) / latRange;
                const scale = Math.min(scaleX, scaleY);
                
                const offsetX = (canvas.width - lonRange * scale) / 2;
                const offsetY = (canvas.height - latRange * scale) / 2;
                
                // Draw track
                ctx.strokeStyle = '#2196f3';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                this.filteredData.forEach((point, index) => {
                    const x = offsetX + (point.longitude - bounds.minLon) * scale;
                    const y = offsetY + (bounds.maxLat - point.latitude) * scale;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // Draw start point
                if (this.filteredData.length > 0) {
                    const startPoint = this.filteredData[0];
                    const startX = offsetX + (startPoint.longitude - bounds.minLon) * scale;
                    const startY = offsetY + (bounds.maxLat - startPoint.latitude) * scale;
                    
                    ctx.fillStyle = '#4caf50';
                    ctx.beginPath();
                    ctx.arc(startX, startY, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Start label
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('START', startX, startY + 4);
                }
                
                // Draw end point (current position)
                if (this.filteredData.length > 1) {
                    const endPoint = this.filteredData[this.filteredData.length - 1];
                    const endX = offsetX + (endPoint.longitude - bounds.minLon) * scale;
                    const endY = offsetY + (bounds.maxLat - endPoint.latitude) * scale;
                    
                    ctx.fillStyle = '#f44336';
                    ctx.beginPath();
                    ctx.arc(endX, endY, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // End label
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('NOW', endX, endY + 4);
                    
                    // Draw accuracy circle
                    if (endPoint.accuracy) {
                        const accuracyRadius = endPoint.accuracy * scale;
                        ctx.strokeStyle = 'rgba(244, 67, 54, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(endX, endY, Math.min(accuracyRadius, 50), 0, 2 * Math.PI);
                        ctx.stroke();
                    }
                }
                
                // Draw scale indicator
                this.drawScaleIndicator(ctx, canvas, scale);
                
                // Draw compass
                this.drawCompass(ctx, canvas);
            }
            
            drawScaleIndicator(ctx, canvas, scale) {
                const scaleLength = 100; // pixels
                const realDistance = scaleLength / scale; // meters
                
                let displayDistance, unit;
                if (realDistance >= 1000) {
                    displayDistance = (realDistance / 1000).toFixed(1);
                    unit = 'km';
                } else {
                    displayDistance = Math.round(realDistance);
                    unit = 'm';
                }
                
                const x = 20;
                const y = canvas.height - 30;
                
                // Draw scale line
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + scaleLength, y);
                ctx.moveTo(x, y - 5);
                ctx.lineTo(x, y + 5);
                ctx.moveTo(x + scaleLength, y - 5);
                ctx.lineTo(x + scaleLength, y + 5);
                ctx.stroke();
                
                // Draw scale text
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${displayDistance} ${unit}`, x + scaleLength / 2, y - 10);
            }
            
            drawCompass(ctx, canvas) {
                if (!this.compassCalibrated) return;
                
                const centerX = canvas.width - 50;
                const centerY = 50;
                const radius = 30;
                
                // Draw compass circle
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Draw compass needle
                const heading = this.toRadians(this.deviceOrientation.alpha || 0);
                const needleLength = radius - 5;
                
                ctx.strokeStyle = '#f44336';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.sin(heading) * needleLength,
                    centerY - Math.cos(heading) * needleLength
                );
                ctx.stroke();
                
                // Draw N indicator
                ctx.fillStyle = '#333';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('N', centerX, centerY - radius - 10);
            }
            
            updateCoordinatesDisplay(point) {
                const display = document.getElementById('coordinatesDisplay');
                if (!display) return;
                
                const lat = point.latitude.toFixed(8);
                const lon = point.longitude.toFixed(8);
                const alt = point.altitude ? point.altitude.toFixed(1) : '---.-';
                const acc = point.accuracy ? point.accuracy.toFixed(1) : '---.-';
                const spd = point.speed ? (point.speed * 3.6).toFixed(1) : '--.-';
                const hdg = point.heading ? point.heading.toFixed(0) : '---';
                const time = new Date(point.timestamp).toISOString().replace('T', ' ').substr(0, 19);
                
                display.innerHTML = `
                    LAT: ${lat}° LON: ${lon}°<br>
                    ALT: ${alt} m  ACC: ${acc} m<br>
                    SPD: ${spd} km/h  HDG: ${hdg}°<br>
                    UTC: ${time}
                `;
            }
            
            updateAccuracyIndicator(accuracy) {
                const indicator = document.getElementById('accuracyIndicator');
                if (!indicator) return;
                
                let className, text;
                
                if (accuracy === null) {
                    className = 'accuracy-poor';
                    text = 'GPS Signal Lost';
                } else if (accuracy <= 5) {
                    className = 'accuracy-excellent';
                    text = `Excellent (±${accuracy.toFixed(1)}m)`;
                } else if (accuracy <= 15) {
                    className = 'accuracy-good';
                    text = `Good (±${accuracy.toFixed(1)}m)`;
                } else if (accuracy <= 50) {
                    className = 'accuracy-fair';
                    text = `Fair (±${accuracy.toFixed(1)}m)`;
                } else {
                    className = 'accuracy-poor';
                    text = `Poor (±${accuracy.toFixed(1)}m)`;
                }
                
                indicator.className = `accuracy-indicator ${className}`;
                indicator.textContent = `Accuracy: ${text}`;
            }
            
            updateStatisticsDisplay() {
                // Point count
                const pointCount = document.getElementById('pointCount');
                if (pointCount) {
                    pointCount.textContent = `${this.filteredData.length} points`;
                }
                
                // Total distance
                const totalDistance = document.getElementById('totalDistance');
                if (totalDistance) {
                    totalDistance.textContent = `${(this.totalDistance / 1000).toFixed(3)} km`;
                }
                
                // Duration
                const duration = document.getElementById('duration');
                if (duration && this.startTime) {
                    const elapsed = Date.now() - this.startTime - this.pausedTime;
                    duration.textContent = this.formatDuration(elapsed);
                }
                
                // Average speed
                const avgSpeed = document.getElementById('avgSpeed');
                if (avgSpeed && this.startTime) {
                    const elapsed = (Date.now() - this.startTime - this.pausedTime) / 1000 / 3600; // hours
                    const avgSpeedValue = elapsed > 0 ? (this.totalDistance / 1000) / elapsed : 0;
                    avgSpeed.textContent = `${avgSpeedValue.toFixed(2)} km/h`;
                }
                
                // Max speed
                const maxSpeed = document.getElementById('maxSpeed');
                if (maxSpeed) {
                    maxSpeed.textContent = `${(this.maxSpeed * 3.6).toFixed(2)} km/h`;
                }
                
                // Elevation gain
                const elevGain = document.getElementById('elevGain');
                if (elevGain) {
                    elevGain.textContent = `${Math.round(this.elevationGain)} m`;
                }
                
                // Track precision
                const trackPrecision = document.getElementById('trackPrecision');
                if (trackPrecision) {
                    const precision = this.calculateTrackPrecision();
                    trackPrecision.textContent = `${precision}%`;
                }
                
                // Track smoothness
                const trackSmoothness = document.getElementById('trackSmoothness');
                if (trackSmoothness) {
                    const smoothness = this.calculateTrackSmoothness();
                    trackSmoothness.textContent = `${smoothness}%`;
                }
                
                // Sensor fusion status
                const fusionStatus = document.getElementById('fusionStatus');
                if (fusionStatus) {
                    const isActive = document.getElementById('sensorFusion')?.checked && this.compassCalibrated;
                    fusionStatus.textContent = isActive ? 'Active' : 'Inactive';
                }
                
                // Update progress bars
                this.updateProgressBars();
            }
            
            calculateTrackPrecision() {
                if (this.filteredData.length < 2) return 0;
                
                let totalAccuracy = 0;
                let validPoints = 0;
                
                this.filteredData.forEach(point => {
                    if (point.accuracy) {
                        totalAccuracy += point.accuracy;
                        validPoints++;
                    }
                });
                
                if (validPoints === 0) return 0;
                
                const avgAccuracy = totalAccuracy / validPoints;
                return Math.max(0, Math.min(100, Math.round(100 - (avgAccuracy / 50) * 100)));
            }
            
            calculateTrackSmoothness() {
                if (this.filteredData.length < 3) return 0;
                
                let totalDeviation = 0;
                let segments = 0;
                
                for (let i = 1; i < this.filteredData.length - 1; i++) {
                    const prev = this.filteredData[i - 1];
                    const curr = this.filteredData[i];
                    const next = this.filteredData[i + 1];
                    
                    const bearing1 = this.calculateBearing(prev.latitude, prev.longitude, curr.latitude, curr.longitude);
                    const bearing2 = this.calculateBearing(curr.latitude, curr.longitude, next.latitude, next.longitude);
                    
                    let deviation = Math.abs(bearing2 - bearing1);
                    if (deviation > 180) deviation = 360 - deviation;
                    
                    totalDeviation += deviation;
                    segments++;
                }
                
                if (segments === 0) return 100;
                
                const avgDeviation = totalDeviation / segments;
                return Math.max(0, Math.min(100, Math.round(100 - (avgDeviation / 45) * 100)));
            }
            
            calculateBearing(lat1, lon1, lat2, lon2) {
                const dLon = this.toRadians(lon2 - lon1);
                const lat1Rad = this.toRadians(lat1);
                const lat2Rad = this.toRadians(lat2);
                
                const y = Math.sin(dLon) * Math.cos(lat2Rad);
                const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
                
                const bearing = Math.atan2(y, x);
                return (bearing * 180 / Math.PI + 360) % 360;
            }
            
            updateProgressBars() {
                // Point progress (arbitrary scale to 1000 points)
                const pointProgress = document.getElementById('pointProgress');
                if (pointProgress) {
                    const progress = Math.min(100, (this.filteredData.length / 1000) * 100);
                    pointProgress.style.width = `${progress}%`;
                }
                
                // Distance progress (arbitrary scale to 10km)
                const distanceProgress = document.getElementById('distanceProgress');
                if (distanceProgress) {
                    const progress = Math.min(100, (this.totalDistance / 10000) * 100);
                    distanceProgress.style.width = `${progress}%`;
                }
                
                // Speed progress (scale to max speed)
                const speedProgress = document.getElementById('speedProgress');
                if (speedProgress && this.maxSpeed > 0) {
                    const progress = Math.min(100, (this.maxSpeed * 3.6 / 100) * 100); // Scale to 100 km/h
                    speedProgress.style.width = `${progress}%`;
                }
            }
            
            formatDuration(milliseconds) {
                const seconds = Math.floor(milliseconds / 1000);
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = seconds % 60;
                
                                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            updateUI() {
                const startBtn = document.getElementById('startBtn');
                const stopBtn = document.getElementById('stopBtn');
                const pauseBtn = document.getElementById('pauseBtn');
                const resumeBtn = document.getElementById('resumeBtn');
                const exportButtons = ['exportGpxBtn', 'exportKmlBtn', 'exportJsonBtn'];
                
                if (this.isTracking) {
                    if (startBtn) startBtn.disabled = true;
                    if (stopBtn) stopBtn.disabled = false;
                    
                    if (this.isPaused) {
                        if (pauseBtn) pauseBtn.style.display = 'none';
                        if (resumeBtn) resumeBtn.style.display = 'inline-block';
                    } else {
                        if (pauseBtn) pauseBtn.disabled = false;
                        if (resumeBtn) resumeBtn.style.display = 'none';
                    }
                } else {
                    if (startBtn) startBtn.disabled = false;
                    if (stopBtn) stopBtn.disabled = true;
                    if (pauseBtn) pauseBtn.disabled = true;
                    if (resumeBtn) resumeBtn.style.display = 'none';
                }
                
                // Enable export buttons if we have data
                const hasData = this.filteredData.length > 0;
                exportButtons.forEach(btnId => {
                    const btn = document.getElementById(btnId);
                    if (btn) btn.disabled = !hasData;
                });
                
                // Update status displays
                const trackingStatus = document.getElementById('trackingStatus');
                if (trackingStatus) {
                    if (this.isTracking) {
                        if (this.isPaused) {
                            trackingStatus.textContent = 'Paused';
                            trackingStatus.className = 'status inactive';
                        } else {
                            trackingStatus.textContent = 'Active';
                            trackingStatus.className = 'status active';
                        }
                    } else {
                        trackingStatus.textContent = 'Inactive';
                        trackingStatus.className = 'status inactive';
                    }
                }
            }
            
            updateConnectionDisplay() {
                const connectionStatus = document.getElementById('connectionStatus');
                const dataUsage = document.getElementById('dataUsage');
                
                if (connectionStatus) {
                    const isOnline = navigator.onLine;
                    connectionStatus.textContent = isOnline ? 'Online' : 'Offline';
                    connectionStatus.className = `status ${isOnline ? 'online' : 'offline'}`;
                }
                
                if (dataUsage) {
                    const usage = this.formatDataUsage(this.dataUsage.session);
                    dataUsage.textContent = usage;
                }
            }
            
            formatDataUsage(bytes) {
                if (bytes < 1024) return `${bytes} B`;
                if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
                return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
            }
            
            trackDataUsage(bytes) {
                this.dataUsage.session += bytes;
                this.dataUsage.total += bytes;
                this.updateConnectionDisplay();
            }
            
            startStatusUpdates() {
                setInterval(() => {
                    this.updateStatisticsDisplay();
                    this.updateConnectionDisplay();
                }, 1000);
            }
            
            clearData() {
                if (this.isTracking) {
                    if (!confirm('Stop tracking and clear all data?')) return;
                    this.stopTracking();
                }
                
                this.trackData = [];
                this.filteredData = [];
                this.sensorData = [];
                this.totalDistance = 0;
                this.maxSpeed = 0;
                this.elevationGain = 0;
                this.elevationLoss = 0;
                this.lastElevation = null;
                this.startTime = null;
                this.pausedTime = 0;
                this.pauseStartTime = null;
                this.trackBounds = { minLat: null, maxLat: null, minLon: null, maxLon: null };
                this.dataUsage.session = 0;
                
                // Clear canvas
                if (this.ctx) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.canvas.style.display = 'none';
                    this.canvas.parentElement.querySelector('.map-placeholder').style.display = 'flex';
                }
                
                // Reset displays
                document.getElementById('coordinatesDisplay').innerHTML = `
                    LAT: -.--------° LON: -.--------°<br>
                    ALT: ---.- m  ACC: ---.- m<br>
                    SPD: --.- km/h  HDG: ---°<br>
                    UTC: ----/--/-- --:--:--
                `;
                
                this.updateAccuracyIndicator(null);
                this.updateStatisticsDisplay();
                this.updateUI();
                
                console.log('All data cleared');
                this.showNotification('All data cleared', 'info');
            }
            
            loadSettings() {
                try {
                    const saved = localStorage.getItem('gpsTrackerSettings');
                    if (saved) {
                        const settings = JSON.parse(saved);
                        
                        // Apply settings to form elements
                        Object.keys(settings).forEach(key => {
                            const element = document.getElementById(key);
                            if (element) {
                                if (element.type === 'checkbox') {
                                    element.checked = settings[key];
                                } else {
                                    element.value = settings[key];
                                }
                            }
                        });
                        
                        // Apply data saving mode
                        this.dataUsage.mode = settings.dataSavingMode || 'minimal';
                    }
                } catch (error) {
                    console.warn('Failed to load settings:', error);
                }
            }
            
            saveSettings() {
                try {
                    const settings = {
                        gpsInterval: document.getElementById('gpsInterval')?.value || '5000',
                        highAccuracy: document.getElementById('highAccuracy')?.checked ?? true,
                        positionTimeout: document.getElementById('positionTimeout')?.value || '15000',
                        maximumAge: document.getElementById('maximumAge')?.value || '10000',
                        sensorFusion: document.getElementById('sensorFusion')?.checked ?? true,
                        trackSmoothing: document.getElementById('trackSmoothing')?.checked ?? true,
                        minAccuracy: document.getElementById('minAccuracy')?.value || '50',
                        minDistance: document.getElementById('minDistance')?.value || '5',
                        dataSavingMode: document.getElementById('dataSavingMode')?.value || 'minimal',
                        enableMapTiles: document.getElementById('enableMapTiles')?.checked ?? false,
                        enableElevationAPI: document.getElementById('enableElevationAPI')?.checked ?? false,
                        enableCloudSync: document.getElementById('enableCloudSync')?.checked ?? false,
                        enableWeatherData: document.getElementById('enableWeatherData')?.checked ?? false,
                        deadReckoning: document.getElementById('deadReckoning')?.checked ?? false
                    };
                    
                    localStorage.setItem('gpsTrackerSettings', JSON.stringify(settings));
                    
                    // Apply data saving mode
                    this.dataUsage.mode = settings.dataSavingMode;
                    this.updateConnectionDisplay();
                    
                    console.log('Settings saved successfully');
                    this.showNotification('Settings saved successfully', 'success');
                    this.closeSettings();
                } catch (error) {
                    console.error('Failed to save settings:', error);
                    this.showError('Failed to save settings: ' + error.message);
                }
            }
            
            closeSettings() {
                const settingsModal = document.getElementById('settingsModal');
                if (settingsModal) {
                    settingsModal.style.display = 'none';
                }
            }
            
            showSettings() {
                const settingsModal = document.getElementById('settingsModal');
                if (settingsModal) {
                    settingsModal.style.display = 'block';
                    this.updateSettingsInfo();
                }
            }
            
            updateSettingsInfo() {
                // Update storage info
                const storageUsed = document.getElementById('storageUsed');
                if (storageUsed) {
                    const dataSize = JSON.stringify(this.trackData).length;
                    storageUsed.textContent = this.formatDataUsage(dataSize);
                }
                
                const pointsStored = document.getElementById('pointsStored');
                if (pointsStored) {
                    pointsStored.textContent = this.trackData.length.toString();
                }
                
                const sessionTime = document.getElementById('sessionTime');
                if (sessionTime && this.startTime) {
                    const elapsed = Date.now() - this.startTime - this.pausedTime;
                    sessionTime.textContent = this.formatDuration(elapsed).substr(0, 5); // HH:MM
                }
            }
            
            exportGPX() {
                if (this.filteredData.length === 0) {
                    this.showError('No track data to export');
                    return;
                }
                
                const gpx = this.generateGPX();
                this.downloadFile(gpx, 'track.gpx', 'application/gpx+xml');
                this.showNotification('GPX file exported successfully', 'success');
            }
            
            exportKML() {
                if (this.filteredData.length === 0) {
                    this.showError('No track data to export');
                    return;
                }
                
                const kml = this.generateKML();
                this.downloadFile(kml, 'track.kml', 'application/vnd.google-earth.kml+xml');
                this.showNotification('KML file exported successfully', 'success');
            }
            
            exportJSON() {
                if (this.filteredData.length === 0) {
                    this.showError('No track data to export');
                    return;
                }
                
                const json = this.generateJSON();
                this.downloadFile(json, 'track.json', 'application/json');
                this.showNotification('JSON file exported successfully', 'success');
            }
            
            generateGPX() {
                const now = new Date().toISOString();
                let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Ultra GPS Tracker Pro" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>GPS Track</name>
    <time>${now}</time>
  </metadata>
  <trk>
    <name>Track ${now.substr(0, 10)}</name>
    <trkseg>`;
                
                this.filteredData.forEach(point => {
                    const time = new Date(point.timestamp).toISOString();
                    gpx += `
      <trkpt lat="${point.latitude}" lon="${point.longitude}">`;
                    
                    if (point.altitude !== null) {
                        gpx += `
        <ele>${point.altitude}</ele>`;
                    }
                    
                    gpx += `
        <time>${time}</time>`;
                    
                    if (point.accuracy) {
                        gpx += `
        <extensions>
          <accuracy>${point.accuracy}</accuracy>
        </extensions>`;
                    }
                    
                    gpx += `
      </trkpt>`;
                });
                
                gpx += `
    </trkseg>
  </trk>
</gpx>`;
                
                return gpx;
            }
            
            generateKML() {
                const now = new Date().toISOString();
                let kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>GPS Track</name>
    <description>Track recorded on ${now.substr(0, 10)}</description>
    <Style id="trackStyle">
      <LineStyle>
        <color>ff0000ff</color>
        <width>3</width>
      </LineStyle>
    </Style>
    <Placemark>
      <name>GPS Track</name>
      <styleUrl>#trackStyle</styleUrl>
      <LineString>
        <tessellate>1</tessellate>
        <coordinates>`;
                
                this.filteredData.forEach(point => {
                    const alt = point.altitude || 0;
                    kml += `${point.longitude},${point.latitude},${alt} `;
                });
                
                kml += `
        </coordinates>
      </LineString>
    </Placemark>
  </Document>
</kml>`;
                
                return kml;
            }
            
            generateJSON() {
                const trackInfo = {
                    metadata: {
                        name: 'GPS Track',
                        created: new Date().toISOString(),
                        totalDistance: this.totalDistance,
                        maxSpeed: this.maxSpeed,
                        elevationGain: this.elevationGain,
                        elevationLoss: this.elevationLoss,
                        duration: this.startTime ? Date.now() - this.startTime - this.pausedTime : 0,
                        pointCount: this.filteredData.length
                    },
                    track: this.filteredData.map(point => ({
                        latitude: point.latitude,
                        longitude: point.longitude,
                        altitude: point.altitude,
                        accuracy: point.accuracy,
                        speed: point.speed,
                        heading: point.heading,
                        timestamp: point.timestamp,
                        sensorData: point.sensorData
                    }))
                };
                
                return JSON.stringify(trackInfo, null, 2);
            }
            
            downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            showNotification(message, type = 'info') {
                // Create notification element
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 15px 20px;
                    border-radius: 10px;
                    color: white;
                    font-weight: 600;
                    z-index: 10000;
                    max-width: 300px;
                                        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                    transform: translateX(100%);
                    transition: transform 0.3s ease;
                `;
                
                // Set background color based on type
                switch (type) {
                    case 'success':
                        notification.style.background = 'linear-gradient(135deg, #4caf50, #45a049)';
                        break;
                    case 'error':
                        notification.style.background = 'linear-gradient(135deg, #f44336, #d32f2f)';
                        break;
                    case 'warning':
                        notification.style.background = 'linear-gradient(135deg, #ff9800, #f57c00)';
                        break;
                    default:
                        notification.style.background = 'linear-gradient(135deg, #2196f3, #1976d2)';
                }
                
                notification.textContent = message;
                document.body.appendChild(notification);
                
                // Animate in
                setTimeout(() => {
                    notification.style.transform = 'translateX(0)';
                }, 100);
                
                // Remove after 3 seconds
                setTimeout(() => {
                    notification.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            document.body.removeChild(notification);
                        }
                    }, 300);
                }, 3000);
            }
            
            showError(message) {
                this.showNotification(message, 'error');
                console.error(message);
            }
        }
        
        // Global tracker instance
        let gpsTracker;
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            gpsTracker = new UltraGPSTracker();
        });
        
        // Global functions for UI interaction
        function startTracking() {
            if (gpsTracker) gpsTracker.startTracking();
        }
        
        function stopTracking() {
            if (gpsTracker) gpsTracker.stopTracking();
        }
        
        function pauseTracking() {
            if (gpsTracker) gpsTracker.pauseTracking();
        }
        
        function resumeTracking() {
            if (gpsTracker) gpsTracker.resumeTracking();
        }
        
        function clearData() {
            if (gpsTracker) gpsTracker.clearData();
        }
        
        function showSettings() {
            if (gpsTracker) gpsTracker.showSettings();
        }
        
        function closeSettings() {
            if (gpsTracker) gpsTracker.closeSettings();
        }
        
        function saveSettings() {
            if (gpsTracker) gpsTracker.saveSettings();
        }
        
        function exportGPX() {
            if (gpsTracker) gpsTracker.exportGPX();
        }
        
        function exportKML() {
            if (gpsTracker) gpsTracker.exportKML();
        }
        
        function exportJSON() {
            if (gpsTracker) gpsTracker.exportJSON();
        }
        
        function toggleCollapsible(element) {
            const content = element.nextElementSibling;
            const chevron = element.querySelector('.chevron');
            
            if (content.classList.contains('active')) {
                content.classList.remove('active');
                chevron.classList.remove('active');
                chevron.textContent = '▼';
            } else {
                content.classList.add('active');
                chevron.classList.add('active');
                chevron.textContent = '▲';
            }
        }
        
        // Handle online/offline events
        window.addEventListener('online', function() {
            if (gpsTracker) {
                gpsTracker.updateConnectionDisplay();
                gpsTracker.showNotification('Connection restored', 'success');
            }
        });
        
        window.addEventListener('offline', function() {
            if (gpsTracker) {
                gpsTracker.updateConnectionDisplay();
                gpsTracker.showNotification('Working offline', 'warning');
            }
        });
        
        // Handle page visibility changes
        document.addEventListener('visibilitychange', function() {
            if (gpsTracker && gpsTracker.isTracking) {
                if (document.hidden) {
                    console.log('App backgrounded - tracking continues');
                } else {
                    console.log('App foregrounded - updating display');
                    gpsTracker.updateStatisticsDisplay();
                }
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', function() {
            if (gpsTracker && gpsTracker.canvas) {
                gpsTracker.canvas.width = gpsTracker.canvas.offsetWidth;
                gpsTracker.canvas.height = gpsTracker.canvas.offsetHeight;
                gpsTracker.drawTrack();
            }
        });
        
        // Prevent accidental page refresh during tracking
        window.addEventListener('beforeunload', function(e) {
            if (gpsTracker && gpsTracker.isTracking) {
                const message = 'GPS tracking is active. Are you sure you want to leave?';
                e.returnValue = message;
                return message;
            }
        });
        
        // Handle modal clicks
        window.addEventListener('click', function(event) {
            const settingsModal = document.getElementById('settingsModal');
            if (event.target === settingsModal) {
                closeSettings();
            }
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey || event.metaKey) {
                switch (event.key) {
                    case 's':
                        event.preventDefault();
                        if (gpsTracker && gpsTracker.isTracking) {
                            stopTracking();
                        } else {
                            startTracking();
                        }
                        break;
                    case 'p':
                        event.preventDefault();
                        if (gpsTracker && gpsTracker.isTracking) {
                            if (gpsTracker.isPaused) {
                                resumeTracking();
                            } else {
                                pauseTracking();
                            }
                        }
                        break;
                    case 'e':
                        event.preventDefault();
                        if (gpsTracker && gpsTracker.filteredData.length > 0) {
                            exportGPX();
                        }
                        break;
                    case 'Delete':
                    case 'Backspace':
                        if (event.shiftKey) {
                            event.preventDefault();
                            clearData();
                        }
                        break;
                }
            }
            
            // ESC to close modal
            if (event.key === 'Escape') {
                closeSettings();
            }
        });
        
        // Service Worker registration for offline functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('/sw.js')
                    .then(function(registration) {
                        console.log('ServiceWorker registration successful');
                    })
                    .catch(function(err) {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }
        
        // Add touch gestures for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        
        document.addEventListener('touchstart', function(e) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        
        document.addEventListener('touchend', function(e) {
            if (!touchStartX || !touchStartY) return;
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const diffX = touchStartX - touchEndX;
            const diffY = touchStartY - touchEndY;
            
            // Swipe detection (minimum 50px)
            if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
                if (diffX > 0) {
                    // Swipe left - could trigger an action
                    console.log('Swipe left detected');
                } else {
                    // Swipe right - could trigger an action 
                    console.log('Swipe right detected');
                }
            }
            
            touchStartX = 0;
            touchStartY = 0;
        });
        
        // Battery status monitoring
        if ('getBattery' in navigator) {
            navigator.getBattery().then(function(battery) {
                function updateBatteryInfo() {
                    console.log('Battery level: ' + (battery.level * 100) + '%');
                    console.log('Battery charging: ' + battery.charging);
                    
                    // Warn if battery is low during tracking
                    if (gpsTracker && gpsTracker.isTracking && battery.level < 0.2 && !battery.charging) {
                        gpsTracker.showNotification('Low battery warning - consider connecting charger', 'warning');
                    }
                }
                
                battery.addEventListener('chargingchange', updateBatteryInfo);
                battery.addEventListener('levelchange', updateBatteryInfo);
                updateBatteryInfo();
            });
        }
        
        // Performance monitoring
        let performanceMetrics = {
            startTime: performance.now(),
            gpsUpdates: 0,
            renderCalls: 0
        };
        
        setInterval(function() {
            if (gpsTracker && gpsTracker.isTracking) {
                const runtime = (performance.now() - performanceMetrics.startTime) / 1000;
                const gpsRate = performanceMetrics.gpsUpdates / runtime;
                const renderRate = performanceMetrics.renderCalls / runtime;
                
                console.log(`Performance: GPS ${gpsRate.toFixed(2)}/s, Render ${renderRate.toFixed(2)}/s`);
            }
        }, 30000); // Log every 30 seconds
        
        // Debug mode toggle
        let debugMode = false;
        
        function toggleDebugMode() {
            debugMode = !debugMode;
            console.log('Debug mode:', debugMode ? 'ON' : 'OFF');
            
            if (debugMode) {
                // Add debug info to display
                document.body.classList.add('debug-mode');
            } else {
                document.body.classList.remove('debug-mode');
            }
        }
        
        // Double-tap on title to toggle debug mode
        let titleTapCount = 0;
        document.querySelector('.header h1').addEventListener('click', function() {
            titleTapCount++;
            setTimeout(function() {
                if (titleTapCount === 2) {
                    toggleDebugMode();
                }
                titleTapCount = 0;
            }, 300);
        });
        
        console.log('Ultra GPS Tracker Pro - Script loaded successfully');
        console.log('Keyboard shortcuts:');
        console.log('  Ctrl+S: Start/Stop tracking');
        console.log('  Ctrl+P: Pause/Resume tracking');
        console.log('  Ctrl+E: Export GPX');
        console.log('  Shift+Delete: Clear data');
        console.log('  ESC: Close settings');
        console.log('Double-click title to toggle debug mode');
    </script>
</body>
</html>





